<!DOCTYPE html>
<html>
  <head>
    <base href='https://towerofnix.github.io/blog/'>
    <meta charset='utf-8'>
    <title>Raspberry Pi madness</title>
    <meta name='Description' content="I got a Raspberry Pi, so, here's some rambling about it and what I've made with it.">
    <meta name='twitter:card' content="summary_image">
    <meta name='twitter:site' content="@towerofnix">
    <meta name='twitter:title' content="Raspberry Pi madness">
    <meta name='twitter:description' content="I got a Raspberry Pi, so, here's some rambling about it and what I've made
    with it.">
    <meta name='twitter:image' content="https://towerofnix.github.io/blog/static/media/11-setup.png">

    <link rel='stylesheet' href='static/site.css'>
  </head>
  <body>
    <div id='main' class='top-block'>
      <div id='nav'>
        <a href='index.html'>(Front.)</a>
        <a href='about.html'>(About!)</a>
        <a href='archive.html'>(Archive.)</a><div class='post-nav'>
              <a href='https://towerofnix.github.io/blog/posts/10-stuff-filled-update.html'>Previous post</a>
              <br>
              <a href='https://towerofnix.github.io/blog/posts/12-nondaily-update.html'>Next post</a>
        </div>
      </div>
      <div id='content'>
        <h1 id="raspberry-pi-madness">Raspberry Pi madness</h1>
        <p>I got a Raspberry Pi, so, here&#39;s some rambling about it and what I&#39;ve made
        with it.</p>
        <p>First things first - the Raspberry Pi is <em>weird.</em> It&#39;s just funny having a tiny
        little computer that can do pretty much anything (that isn&#39;t terribly
        computationally powerful). I guess it&#39;s not too surprising, since mobile
        devices are already way more powerful (and nearly smaller) than the Raspberry
        Pi; but this thing feels a bit different, maybe because I&#39;m actually able to
        program it..? (But then there&#39;s Pythonista, too. Maybe it&#39;s the ability to
        SSH into the box sitting on my desk?)</p>
        <p>It&#39;s also just fun to look at. I took a picture of it:</p>
        <p><img src="static/media/11-setup.png" alt="Setup"></p>
        <p>(That picture looks an awful lot like an album cover.)</p>
        <p>Although my new setup is a bit less crazy (I got rid of the HDMI output,
        keyboard and mouse).</p>
        <p>There&#39;s one distinct thing in that photo, though - the radio. I&#39;ve got three
        reasons for using that radio, instead of the HDMI TV output:</p>
        <p><strong>Reason one:</strong> I don&#39;t want it to rely on HDMI, since sometimes HDMI might
        not be available.</p>
        <p><strong>Reason two:</strong> Radios give a nicer feeling. Having the radio speaker output
        sound seems more friendly than a gigantic TV (and/or a dedicated monitor)
        doing it.</p>
        <p><strong>Reason three:</strong> I wasn&#39;t using the radio anyways.</p>
        <p>Okay, but, <em>what am I doing with it?</em></p>
        <p>Short answer: it&#39;s playing my iTunes library.</p>
        <p>Long answer: it&#39;s downloading song files I have in my iTunes media folder and
        playing those. No files are stored on the Raspberry Pi (except for the
        currently playing track). I also made it be able to filter things by &quot;group&quot;,
        which really just means by artist and (optionally) album.</p>
        <p>..Ah, who am I kidding? This intro&#39;s way too long. I just want to show how it
        actually works!</p>
        <hr>
        <h2 id="generating-the-playlist">Generating the Playlist</h2>
        <p>The first thing we need to do is create a file containing all the songs and the
        URLs we can use to download them. I like using <code>python3 -m http.server</code> as my
        main static server, because it only takes that one command to use, so we&#39;ll try
        to parse the output of that.</p>
        <p>Thankfully, the format for directory listings with that server is relatively
        simple; every <code>&lt;a&gt;</code> on the page links to a file or a deeper folder. Since we&#39;re
        building a <em>tree</em> of the entire library (root -&gt; artists -&gt; albums), we&#39;ll need
        to navigate the directory recursively; to do that we just run the crawl-folder
        function on every <code>&lt;a&gt;</code> href-path that ends with <code>/</code>.</p>
        <p>Like I noted, the tree we end up with goes from the root folder, to a folder
        for each artist, and then a folder for each of an artist&#39;s albums.</p>
        <p>There&#39;s actually a setting in the iTunes preferences that does all of that
        sorting for us - under Advanced Preferences, &quot;Keep iTunes Media folder
        organized&quot;. That&#39;s enabled by default, I think. How convenient.</p>
        <p>I wrote the program that crawls the <code>python3</code> server in a separate file from
        the main <code>play.js</code> script; <code>crawl-itunes.js</code>. In fact, it doesn&#39;t <em>require</em>
        iTunes in any way; really it&#39;ll generate a tree for any <code>python3</code> (or similar)
        server. (It probably won&#39;t work if the server gives parent-directory links, or
        if there&#39;s links; it isn&#39;t built to deal with potential infinite recursion,
        since that&#39;s not a problem in my case.)</p>
        <h2 id="picking-the-track">Picking the Track</h2>
        <p>Our playlist file essentially acts as a big listing of track titles and links
        to the HTTP download for respective files; we&#39;ll use it to pick our song.
        (That&#39;s what it&#39;s made for, after all!)</p>
        <p>The thing is, we want to randomly pick a track from all the tracks in our
        playlist file. But our playlist file is a tree. We have two options here:</p>
        <ul>
        <li><p>Recursively pick a random file or sub-group, until we hit a file. Use that.</p>
        </li>
        <li><p>Flatten the tree, then pick a random item. Use that.</p>
        </li>
        </ul>
        <p>I went with the second option. The actual code behind it is boring, obviously,
        so I won&#39;t bother going over it; but in summary we really are just flattening
        the tree and picking a random item.</p>
        <p>Also, now&#39;s a good time to mention the optional &quot;group path&quot; option I made for
        the program. If it&#39;s specified, the track-selector will only pick from tracks
        under the passed group. (Sub-groups are split by <code>/</code>; so, for example, you
        could make it only pick tracks from <em>Epic Battle Fantasy IV</em> by giving it the
        group path string <code>&#39;Phyrnna/Epic Battle Fantasy IV&#39;</code>.)</p>
        <h2 id="downloading-the-music">Downloading the Music</h2>
        <p>Before we can actually play anything, we&#39;ll need to download the track we want.
        Just downloading the entire track before playing it works; the Raspberry Pi and
        the device with the iTunes library are on the same network, so there&#39;s no
        significant buffering.</p>
        <p>Our picked track playlist-item conveniently stores two pieces of information:
        the title of the song[*] and the download link for it. Clearly we&#39;ll need the
        download link. It&#39;s just the HTTP URL we can fetch to download the track; so
        that&#39;s what we do.</p>
        <p>[*] Really the text between <code>&lt;a href=&quot;..&quot;&gt;</code> and <code>&lt;/a&gt;</code>; not the actual
        title of the track that&#39;s stored in the file&#39;s metadata. I&#39;m too lazy to
        figure out how to get that, plus I think some formats don&#39;t even have any
        metadata of that sort.</p>
        <h2 id="converting-the-audio-file">Converting the Audio File</h2>
        <p>Before we can actually play the file, we still need to do one thing.
        Realistically, our files aren&#39;t going to all be in a format the play command
        we&#39;re using will accept; we need to convert them to a standard format, like
        WAV, first.</p>
        <p>That&#39;s not actually difficult, though. We can use <code>avconv</code>[*] to convert the
        downloaded file using a child process; that&#39;s just <code>avconv -y -i in out.wav</code>.
        (<code>-y</code> is there to ignore any &quot;should this file be overwritten?&quot; prompts.)</p>
        <p>[*] Originally I&#39;d thought to use <code>ffmpeg</code>, but apparently that doesn&#39;t
        actually exist as a proper package, and <code>avconv</code> is the more standard fork
        people use. But it looks like <code>ffmpeg</code> and <code>avconv</code> work basically the same
        way, at least to the user; so at least I didn&#39;t also have to learn a whole new
        command-line program!</p>
        <h2 id="playing-the-audio-file">Playing the Audio File</h2>
        <p>Playing the audio file is as easy as running the <code>play</code> command. In fact,
        that&#39;s what we do!</p>
        <p>This step is actually that stupidly simple. It&#39;s literally just <code>play out.wav</code>.</p>
        <p>And then we loop back to picking another track!</p>
        <h2 id="what-else-can-this-do-">What else can this do?</h2>
        <p>I&#39;d like to make a playlist file that somehow plays music from a YouTube
        channel that has tons of music uploads; SiIvaGunner and HeavyMetal Rocker1988
        come to mind. That shouldn&#39;t be too hard to do, but it would probably mean
        either making an in-between server that downloads and responds with the
        downloaded YouTube audio (<em>stupid!</em>) or making the program work by downloading
        YouTube audio, directly onto the Raspberry Pi (not stupid).</p>
        <p>Making it into an actual radio transmitter would be cool, too.</p>
        
        <p class='post-meta'>
          (-Florrie,
            <a href='https://towerofnix.github.io/blog/posts/11-raspberry-pi-madness.html'><time datetime='2017-5-26'>May 26, 2017</time></a>
            (<a href='https://towerofnix.github.io/blog/posts/11-raspberry-pi-madness.md'>markdown</a>);
            categories: <a href='archive/text.html'>Text-based Posts</a>, <a href='archive/dev.html'>Development</a>)
        </p>
        <p class='post-meta'>
              <a href='https://towerofnix.github.io/blog/posts/10-stuff-filled-update.html'>Previous post</a>
              <br>
              <a href='https://towerofnix.github.io/blog/posts/12-nondaily-update.html'>Next post</a>
        </p>
      </div>
    </div>
    <footer class='top-block'>
      <p>My posts and art are licensed under
         <a href='https://creativecommons.org/licenses/by-sa/4.0/'>
         CC BY-SA 4.0</a>, and this blog's source code is available
         <a href='https://git.ed1.club/florrie/blog.git'>online</a>!</p>
    </footer>
  </body>
</html>